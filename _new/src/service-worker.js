import {timestamp, files, shell, routes} from '@sapper/service-worker';

importScripts('https://storage.googleapis.com/workbox-cdn/releases/4.3.1/workbox-sw.js');
workbox.setConfig({debug: false})
workbox.googleAnalytics.initialize();

const ASSETS = `cache${timestamp}`;

// `shell` is an array of all the files generated by the bundler,
// `files` is an array of everything in the `static` directory
const toCache = shell.concat(files)
  .filter((f) => !f.endsWith('.DS_Store'))
  .filter((f) => !f.startsWith('articleimgs/'))
  .concat([
    'https://fonts.gstatic.com/s/sourcesanspro/v13/6xK3dSBYKcSV-LCoeQqfX1RYOo3qOK7lujVj9w.woff2',
    'https://fonts.gstatic.com/s/sourcesanspro/v13/6xKydSBYKcSV-LCoeQqfX1RYOo3ig4vwlxdu3cOWxw.woff2',
    'articles.json',
  ])

const precached = new Set(toCache)

self.addEventListener('install', event => {
  event.waitUntil(
    caches
      .open(ASSETS)
      .then(cache => cache.addAll([...precached]))
      .then(() => {
        self.skipWaiting();
      })
  );
});

self.addEventListener('activate', event => {
  event.waitUntil(
    caches.keys().then(async keys => {
      // delete old caches
      for (const key of keys) {
        if (key !== ASSETS) await caches.delete(key);
      }

      self.clients.claim();
    })
  );
});

const isImage = (path) => {
  path = path.toLowerCase()
  return path.endsWith('.jpg') || path.endsWith('.jpeg') || path.endsWith('.png')
}

self.addEventListener('fetch', event => {
  if (event.request.method !== 'GET' || event.request.headers.has('range')) return;

  const url = new URL(event.request.url);

  // don't try to handle e.g. data: URIs
  if (!url.protocol.startsWith('http')) return;

  // ignore dev server requests
  if (url.hostname === self.location.hostname && url.port !== self.location.port) return;

  // always serve static files and bundler-generated assets from cache
  if (precached.has(url.pathname.substring(1)) || precached.has(event.request.url)) {
    event.respondWith(caches.match(event.request));
    return;
  }

  // for pages, serve a shell `service-worker-index.html` file
  if (url.origin === self.origin && !url.pathname.endsWith('.json') && routes.find(route => route.pattern.test(url.pathname))) {
    event.respondWith(caches.match('service-worker-index.html'));
    return;
  }

  if (event.request.cache === 'only-if-cached') return;

  // for everything else, try the cache first, falling back to network
  event.respondWith(
    caches
      .open(`offline${timestamp}`)
      .then(async cache => {
        const cachedResponse = await cache.match(event.request);
        if (cachedResponse) return cachedResponse;

        const networkResponse = await fetch(event.request);

        if (networkResponse.ok) {
          cache.put(event.request, networkResponse.clone());
        } else if (isImage(url.pathname)) {
          return caches.match('placeholder.png')
        }
        return networkResponse;
      })
      .catch((err) => {
        if (isImage(url.pathname)) {
          return caches.match('placeholder.png')
        }

        throw err
      })
  );
});
